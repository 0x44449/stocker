# Admin Web - 뉴스 매핑 목록 API

## 배경

- Admin Web 프론트엔드가 Mock 데이터로 동작 중
- 실제 API 연결 필요
- 첫 번째 API로 목록 조회 구현하여 템플릿 확립

## 목표

뉴스 매핑 목록 API 구현 (GET /api/admin/news-mappings)

---

## 기존 엔티티 구조

### NewsRawEntity
**위치:** `com.hanzi.stocker.ingest.news.NewsRawEntity`

```java
@Entity
@Table(name = "news_raw")
public class NewsRawEntity {
    @Id @GeneratedValue private Long id;
    private String source;
    private String press;
    private String title;
    private String rawText;      // 본문
    private String url;
    private LocalDateTime publishedAt;
    private LocalDateTime collectedAt;
    private LocalDateTime expiresAt;
}
```

### CompanyNameMappingEntity
**위치:** `com.hanzi.stocker.entities.CompanyNameMappingEntity`

```java
@Entity
@Table(name = "company_name_mapping")
public class CompanyNameMappingEntity {
    @Id @GeneratedValue private Long id;
    private Long newsId;              // FK 관계 설정 안 됨
    private String extractedName;
    private String matchedStockCode;  // stock_master.stock_code 참조
    private String matchType;         // 'auto_exact', 'manual', 'none'
    private Boolean verified;
    private String feedback;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}
```

### StockMasterEntity
**위치:** `com.hanzi.stocker.ingest.krx.master.StockMasterEntity`

```java
@Entity
@Table(name = "stock_master")
public class StockMasterEntity {
    @Id private String isinCode;
    private String stockCode;       // UNIQUE
    private String nameKr;
    private String nameKrShort;
    private String market;
    // ...
}
```

---

## 테이블 관계

```
news_raw (1) ──< (N) company_name_mapping
            news_id = news_raw.id
            
company_name_mapping >── (0..1) stock_master
            matched_stock_code = stock_master.stock_code
```

- 하나의 뉴스에 여러 개의 매핑이 있음
- 각 매핑은 종목에 연결되거나 NULL

---

## API 명세

### Request
```
GET /api/admin/news-mappings?filter=all&page=0&size=10&search=
```

**파라미터:**
| 이름 | 타입 | 기본값 | 설명 |
|------|------|--------|------|
| filter | string | all | all / unmatched / done |
| page | int | 0 | 페이지 번호 (0부터) |
| size | int | 10 | 페이지 크기 |
| search | string | - | 검색어 (제목, 기업명) |

### Response
```json
{
  "items": [
    {
      "newsId": 1,
      "title": "현대차그룹, 전기차 배터리 투자 확대...",
      "extractedNames": ["현대차그룹", "LG에너지솔루션"],
      "matchedCount": 1,
      "totalCount": 2,
      "status": "auto_pending"
    }
  ],
  "totalCount": 100,
  "page": 0,
  "size": 10
}
```

---

## 쿼리 로직

### 데이터 흐름

```
1. news_raw 테이블 기준
2. company_name_mapping LEFT JOIN (news_id = news_raw.id)
3. 각 뉴스별 집계:
   - extractedNames: DISTINCT extracted_name 목록 (NULL 제외)
   - totalCount: 매핑 레코드 수 (0 가능)
   - matchedCount: matched_stock_code IS NOT NULL 수
   - status: 계산 (아래 참조)
4. 필터/검색 조건 적용
5. 페이지네이션
```

**주의:** LEFT JOIN이므로 매핑이 없는 뉴스도 포함됨.

### 집계 필드 계산

| 필드 | SQL 표현 |
|------|----------|
| extractedNames | `ARRAY_AGG(DISTINCT extracted_name)` 또는 서비스 레이어에서 처리 |
| totalCount | `COUNT(*)` GROUP BY news_id |
| matchedCount | `COUNT(matched_stock_code)` 또는 `SUM(CASE WHEN matched_stock_code IS NOT NULL THEN 1 ELSE 0 END)` |

### status 계산 로직

**주의: status는 DB에 저장되지 않음. API 응답 시 verified, match_type 값을 조합해 서버에서 계산.**

```
뉴스의 매핑(company_name_mapping) 레코드에 대해:

IF 매핑 레코드가 0개 THEN 'no_mapping'
ELSE IF 모든 verified = true THEN 'done'
ELSE IF 일부 verified = true THEN 'partial'  
ELSE IF match_type = 'auto_exact'인 것이 하나라도 있으면 'auto_pending'
ELSE 'unmapped'
```

**status 색상:**
| status | 색상 |
|--------|------|
| no_mapping | 회색 |
| unmapped | 빨강 |
| auto_pending | 노랑 |
| partial | 주황 |
| done | 파랑 |

### 필터 조건

| filter | 포함되는 status |
|--------|------------------|
| all | 전체 |
| unmatched | no_mapping, unmapped, auto_pending |
| done | done |

### 검색 조건

```sql
WHERE news_raw.title ILIKE '%검색어%'
   OR company_name_mapping.extracted_name ILIKE '%검색어%'
```

---

## 구현 방식: Querydsl

엔티티 필드 변경 시 컴파일 타임 체크를 위해 Querydsl 사용.

### 설정 필요 사항

**1. build.gradle 의존성:**
```groovy
// Querydsl
implementation 'com.querydsl:querydsl-jpa:5.1.0:jakarta'
annotationProcessor 'com.querydsl:querydsl-apt:5.1.0:jakarta'
annotationProcessor 'jakarta.persistence:jakarta.persistence-api'
annotationProcessor 'jakarta.annotation:jakarta.annotation-api'
```

**2. JPAQueryFactory 빈 등록:**
```java
@Configuration
public class QuerydslConfig {
    @Bean
    public JPAQueryFactory jpaQueryFactory(EntityManager em) {
        return new JPAQueryFactory(em);
    }
}
```

**3. 빌드하면 Q클래스 자동 생성:**
- QNewsRawEntity
- QCompanyNameMappingEntity

---

## 할 것

### 1. Querydsl 설정
- build.gradle 의존성 추가
- QuerydslConfig 클래스 생성
- 빌드하여 Q클래스 생성 확인

### 2. API 구현 (Spring Boot)
- AdminNewsMappingController
- AdminNewsMappingService
- Querydsl로 쿼리 작성 (JOIN + 집계)

### 3. 프론트엔드 연결
- API 호출 함수 (src/lib/api.ts)
- Mock → 실제 API 교체
- 환경변수 API URL

### 4. 프론트엔드 타입 수정
- MappingStatus에 'no_mapping' 추가
- STATUS_CONFIG에 no_mapping 색상(회색) 추가

---

## 안 할 것

- 인증/권한
- 캐싱
- 복잡한 에러 핸들링

---

## 완료 조건

- [ ] Querydsl 설정 완료 (Q클래스 생성됨)
- [ ] GET /api/admin/news-mappings 동작
- [ ] 필터 (all/unmatched/done) 동작
- [ ] 검색 (제목, 기업명) 동작
- [ ] 페이지네이션 동작
- [ ] 매핑 없는 뉴스도 목록에 표시 (status: no_mapping)
- [ ] 프론트엔드 no_mapping 상태 표시 (회색 아이콘)
- [ ] 프론트엔드에서 실제 API 데이터 표시
